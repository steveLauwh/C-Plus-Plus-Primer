## 继承

* 面向对象程序设计的核心思想是数据抽象、继承和动态绑定。
* 基类和派生类。
* 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
* 任何构造函数之外的非静态函数都可以是虚函数。
* 访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见。
* 每个类控制它自己的成员初始过程。
* 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。
* 不存在从基类向派生类的隐式类型转换。
* 已知某个基类向派生类的转换是安全的，则可以使用 static_cast 来强制覆盖掉编译器的检查工作。
* 如果在基类中含有一个或多个虚函数，可以使用 dynamic_cast 请求一个类型转换，该转换的安全检查将在运行时执行。
* 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

## 动态绑定

* 运行时绑定。
* 当使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。

## 抽象基类

含有纯虚函数的类是抽象基类，抽象基类是不能创建对象。

## 访问控制与继承

派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响。

派生访问说明符的目的是控制派生类用户对于基类成员的访问权限。

## C++ 11 的新特性

**虚函数的 override 指示符**

允许派生类显示地注明它使用某个成员函数覆盖了它继承的虚函数，添加一个关键字 override。

**通过定义类为 final 来阻止继承**

防止继承的发生，在类名后跟一个关键字 final。

**虚函数的 override 和 final 指示符**

如果使用 override 标记某个函数，但该函数并没有涵盖已存在的虚函数，此时编译器将报错。

把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误。

**删除的拷贝控制和继承**

派生类的析构函数，除了销毁派生类自己的成员外，还负责销毁派生类的直接基类。

派生类中删除的拷贝控制与基类的关系。

**继承的构造函数**

派生类能够重用其直接基类定义的构造函数。

派生类继承基类构造函数的方式是提供一条注明了基类名的 using 声明语句。
