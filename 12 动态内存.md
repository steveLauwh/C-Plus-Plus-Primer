## 动态内存与智能指针

* 栈内存用来保存定义在函数内的非 static 对象。
* 静态内存用来保存局部 static 对象、类 static 数据成员、定义在任何函数之外的变量。
* 堆来存储动态分配的对象。
* 动态内存的管理是通过一对运算符来完成的：new 和 delete。
* make_shared 最安全的分配和使用动态内存的方法。 `shared_ptr<int> p = make_shared<int>(42);`
* shared_ptr 自动销毁所管理的对象。
* 使用动态内存的一个常见原因是允许多个对象共享相同的状态。
* 使用 new 动态分配和初始化对象。

## 动态数组

* `int *p = new int[42];`
* 动态数组不是数组类型。
* 释放动态数组: delete [] p;

## C++ 11 的新特性

**智能指针**

新的标准库提供了两种智能指针类型来管理动态对象。

* shared_ptr 允许多个指针指向同一对象。
* unique_ptr 独占所指向的对象。
* weak_ptr 一种弱引用，指向 shared_ptr 所管理的对象。

**shared_ptr 类**

智能指针也是模板，必须提供额外的信息——指针可以指向的类型。

**动态分配对象的列表初始化**

使用列表初始化(花括号)。

`vector<int> *pv = new vector<int>{0, 1, 2, 3, 4, 5, 6};`

**auto 和动态分配**

`auto p = new auto(obj);  // p 指向一个与 obj 类型相同的对象，该对象用 obj 进行初始化。`

**unique_ptr 类**

一个 unique_ptr 拥有它所指向的对象，当 unique_ptr 被销毁时，它所指向的对象也被销毁。

**weak_ptr 类**

weak_ptr 是一种不控制所指对象生存期的智能指针，它指向由一个 shared_ptr 管理的对象。

**范围 for 语句不能应用于动态分配数组**

由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 或 end；也不能用范围 for 语句来处理动态数组中的元素。

**动态分配数组的列表初始化**

初始化动态分配对象的数组，使用花括号列表：

`int *pia = new int[10]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};`

**auto 不能用于分配数组**

可以用空括号对数组中元素进行值初始化，但不能在括号中给出初始化器，这意味着不能用 auto 分配数组。

**allocator::construct 可使用任意构造函数**

allocator 分配的内存是未构造的。

定义一个 allocator 类来分配动态内存块。
